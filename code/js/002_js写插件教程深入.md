
> ##### 原文地址：[https://github.com/lianxiaozhuang/blog](https://github.com/lianxiaozhuang/blog)
> ##### 转载请注明出处

### js 写插件教程深入

> 1.介绍具有安全作用域的构造函数
```js
function Fn(name){
   this.a = name;
}
Fn.prototype = {
    constructor:Fn,
    getF:function(){
        console.log(1);
    }
}
new Fn();
//new 出来的Fn就是一个构造函数
//倘若有人忘记写new，直接调用Fn();此时var p = Fn();可见实例p没有getF的方法；
//为了解决这种问题；引入了安全作用域的构造函数概念

function Fn(name){
  if(!(this instanceof Fn)){
      //只要不是new的，用Fn()直接调用的，这里的this绝对不指向Fn；让他从
      //新new一下；知道下一次代码走else里的内容，故把this.a 放到了else里

      return new Fn(name)
  }else{
      this.a = name;
  }
}
Fn.prototype = {
    constructor:Fn,
    getF:function(){
        console.log(1);
    }
}

```

> 2.默认参数
```js
 //我们用过一些插件，是可以传一些配置参数的，当然如果你不传的话它有默认的值，
 function Fn(params){
    var defaults = {
        width:100,
        color:"#000"
    };
    var params = params||{}; 
    for (var x in defaults) {
        if (typeof params[x] === 'undefined') {
            params[x] = defaults[x];
            //对于使用时，没有设置的参数；用默认参数代替
        }  
    }
    this.params= params;//得到的this.params,在方法中调用；
   
 }
 Fn.prototype = {

 }
```
> 3.方法到底写到this里还是prototype 里
```js
//举个例子
//①
function Fn(){
    this.getC = function(){
        //...
    }
}
//or...
//②
function Fn(){}
Fn.prototype.getC = function(){}
//大家可能都会有这样的纠结，getC到底写到this里还是原型里
//这要从内存说起；写到原型上，每执行一个实例，getC不需要开辟新的内存
//故，可以把一些纯计算的方法，写原型上，如果方法和实例本身有关，应该写道this中
```
> 4.方法名防止冲突处理

```js
//如果在引入你的插件之前，window下已经有Fn的变量；怎么办,你如果这么搞； 岂不是把别人写的Fn搞掉了
//此时应该把Fn的控制权交出，自己用Fn2输出
(function(){
    var Fn=function(){
            console.log(000)
        }
        Fn.prototype =  {
            
        }
        if(window.Fn){
            throw Error("Fn已经存在，请使用Fn2")
            window.Fn2 = Fn	;
            console.log("lkdk")
        }else{
                window.Fn2 = Fn	;
        }
}())

```
> 5.对外输出的规范化exprot 、amd

```js
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.echarts = {})));
}(this, (function (exports) { 'use strict';

})))


(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else if(typeof define === 'function' && define.amd) {
        define([], factory);
    }else {
            factory( global );
    }

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
    var Fn =  function(){}

    return Fn;
}))

```